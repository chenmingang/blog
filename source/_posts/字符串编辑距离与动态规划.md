---
title: 字符串编辑距离与动态规划
date: 2016-11-14 22:32:13
tags: 随笔
---

> 算法非原创，只是整理，并尝试说的更完整和易理解。

### 字符串编辑距离是什么
将一个字符串转换成另一个字符串时需要付出的代价。转换可以采用插入、删除、替换三种编辑方式。比如说把字符串“post”转换成“get”，直观看来它们的编辑距离颇大，并有许多种转换方式。第一种[替换p为g，替换o为e，删除s]这样它们的转换代价为3。第二种[删除p，删除o，删除s，删除g，删除e]这样它们的转换代价为5。不同的转换方式需要的编辑次数不一样，最少的那个编辑方式所需的次数就是这量字符串的编辑距离。
### 简单的递归算法
咋一看这个问题似乎挺难，因为对同一个字符串需要选择在不同位置上采用不同的动作才能完成任务，可能会有一种无法下手的感觉。但是用计算机的思维方式来看，我们可以把一个复杂的大问题转换成一系列简单的小问题，有多简单呢？比如要把“post”转换成“get”,我们可以先考虑如何把“p”转换成“g”，然后是把“po”转换成“ge”，也就是用一种递归的方式去处理.因为对每一步转换可选择三种不同的方式(插入、删除、替换)，所以需要对比每一部的最优方式。为了调试简单所以就用js做示例。

```js
function editDis(str1,str2){
    if(str1.length==0||str2.length==0){
       return Math.abs(str1.length-str2.length)
    }
    if(str1.charAt(0)===str2.charAt(0)){
       return editDis(str1.substr(1,str1.length),str2.substr(1,str2.length))
    }
    var edInsert = editDis(str1,str2.substr(1,str2.length))+1;
    var edDelete = editDis(str1.substr(1,str1.substr.length),str2)+1;
    var edReplace = editDis(str1.substr(1,str1.substr.length),str2.substr(1,str2.length))+1;
    return Math.min(edInsert,edDelete,edReplace);
}
```
运行结果如下
```js
editDis("post","get")
3
```
### 优化的递归算法
可以看到上边的简单算法就可以得出正确的结果了，虽然简单却造成了大量的计算浪费，时间复杂度太高，在很多子串上做了重复计算。优化？最先想到的是什么？做缓存啊，把计算过的结果存在表里下次计算首先查表就可以了。照我的习惯就直接弄一个map做缓存了，但本文的主题不还有动态规划么，所以考虑用动态规划的思想去解决。

